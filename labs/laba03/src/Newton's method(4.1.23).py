# -*- coding: utf-8 -*-
"""ЛP№3_ПаршинаСР.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/12qRO9qOMm6Ff4qKLEgEEJ0534s-DcFLs
"""

import numpy as np
import matplotlib.pyplot as plt
import math
from scipy.misc import derivative
from scipy import optimize
from sympy import *

x1range = np.arange(-2, 2, 0.01)
x2range = np.arange(-2, 2, 0.01)
x1, x2 = np.meshgrid(x1range,x2range)
plt.contour(x1, x2, (np.tan(x1*x2+0.2)-x1**2), [0], colors='orange')
plt.contour(x1, x2, (0.6*x1**2+2*x2**2-1), [0], colors='b')
plt.xlabel("x1")
plt.ylabel("x2")
plt.grid()
plt.savefig('nonlinear_newton.png', dpi=300)
plt.show()

x1, x2 = symbols('x1 x2')
n = 2
def f1(x1, x2):
    return tan(x1*x2+0.2) - x1**2
def f2(x1, x2):
    return 0.6*x1**2+2*x2**2 - 1
f1_lamb = lambdify((x1, x2), f1(x1, x2), 'numpy')
f2_lamb = lambdify((x1, x2), f2(x1, x2), 'numpy')
def f(x):
    return np.array([f1_lamb(x[0], x[1]), f2_lamb(x[0], x[1])])
def Jac(x):
    j = np.empty((n, n))
    j[0, 0] = diff(f1(x1, x2), x1).evalf(subs={x1: x[0], x2: x[1]})
    j[0, 1] = diff(f1(x1, x2), x2).evalf(subs={x1: x[0], x2: x[1]})
    j[1, 0] = diff(f2(x1, x2), x1).evalf(subs={x1: x[0], x2: x[1]})
    j[1, 1] = diff(f2(x1, x2), x2).evalf(subs={x1: x[0], x2: x[1]})
    return j
eps = 1e-6

sols = [0, 0, 0, 0]
first_approx = [[1, 0.6], [0, 0.7], [-1, 0.6],  [0, -0.7]]
for i in range(len(sols)):
    sols[i] = optimize.root(f, first_approx[i])
    print(f'Встроенная функция. Корень для первого приближения {first_approx[i]}: {sols[i].x}')

def newton(fun, x, eps, jac):
    max_iter = 1000
    i = 0
    x0 = x
    delta = np.linalg.solve(jac(x0), fun(x0)*(-1))
    x1 = x0+delta
    while i < max_iter and np.linalg.norm(x1-x0) > eps:
        delta = np.linalg.solve(jac(x1), fun(x1)*(-1))
        x0 = x1
        x1 = x1+delta
        i+=1
    return [x1, i]

newtone_sols = [0, 0, 0, 0]
for i in range(len(newtone_sols)):
    newtone_sols[i] = newton(f, first_approx[i] , eps, Jac)
    print(f'Метод Ньютона. Корень для первого приближения {first_approx[i]}: {newtone_sols[i][0]}, Число итераций: {newtone_sols[i][1]}')
    newton(f, [1, 0.6], eps, Jac)



